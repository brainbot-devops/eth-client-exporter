#!/usr/bin/env python3
"""Metrics exporter for ethereum clients.

Exposed Metrics:

========================  ==========================  ===========
Metric Name               Labels                      Metric Type
========================  ==========================  ===========
eth_peers                 [peer_state]                Gauge
------------------------  --------------------------
eth_block_transactions    [block_type]
------------------------  --------------------------
eth_hashrate              []
------------------------
eth_gas_price
------------------------
eth_sync_block_pending
------------------------
eth_sync_block_earliest
------------------------
eth_sync_block_latest
------------------------                              -----------
eth_node_sync                                         Enum
========================  ==========================  ===========

"""

import argparse
import time

import requests

from prometheus_client import start_http_server, REGISTRY
from prometheus_client.core import GaugeMetricFamily, CounterMetricFamily, InfoMetricFamily

from web3 import Web3, HTTPProvider


parser = argparse.ArgumentParser()
parser.add_argument('--target-ip', help='Host address of RPC interface to scrape from.', required=True)
parser.add_argument('--target-port', help='Port of the host.', default=8545)
parser.add_argument('--metrics-port', help="The port on which we'll serve our /metrics endpoint", default=9999)
CLI_ARGS = parser.parse_args()


class PEER_STATE:
    CONNECTED = 'connected'
    ACTIVE = 'active'  # parity client only


class BLOCK_TYPE:
    EARLIEST = 'earliest'
    PENDING = 'pending'
    LATEST = 'latest'

    @classmethod
    def as_list(cls):
        return [cls.EARLIEST, cls.PENDING, cls.LATEST]


class SYNC_STATE:
    SYNCING = 'syncing'
    NOT_SYNCING = 'not syncing'

    @classmethod
    def as_list(cls):
        return [cls.SYNCING, cls.NOT_SYNCING]


class LABELS:
    PEER_STATE = PEER_STATE
    BLOCK_TYPE = BLOCK_TYPE



def ignore_httperror(func):
    """Ignore HTTPErrors raised while requesting metrics."""
    def wrapper(*args):
        try:
            return func(*args)
        except requests.HTTPError:
            return None
    return wrapper


class EthereumCollector:

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.rpc = HTTPProvider(f'http://{CLI_ARGS.target_ip}:{CLI_ARGS.target_port}')
        self.web3 = Web3(self.rpc)
        self.metrics = None

    def collect(self):
        self.metrics = {
            'eth_peers': GaugeMetricFamily('eth_peers', 'The number of connected peers.', None, ['peer_state']),
            'eth_block_transactions': GaugeMetricFamily('eth_block_transactions', 'Number of transactions in a block.', None, ['block_type']),
            'eth_hashrate': GaugeMetricFamily('eth_hashrate', 'The current hashrate of the network.'),
            'eth_gas_price': GaugeMetricFamily('eth_gas_price', 'The current gas price of the network.'),
            'eth_sync_block_earliest': GaugeMetricFamily('eth_sync_block_earliest', 'The block at which import started'),
            'eth_sync_block_pending': GaugeMetricFamily('eth_sync_block_pending', 'The most recent block'),
            'eth_sync_block_latest': GaugeMetricFamily('eth_sync_block_latest', 'The estimated highest block.'),
            'eth_node_syncing': CounterMetricFamily('eth_node_syncing', 'Whether or not the node is syncing.'),
            'eth_client_version': InfoMetricFamily('eth_client_version', 'Version of the ethereum client.')
        }
        if self.web3:
            self.collect_peers()
            self.collect_node_sync_status()
            self.collect_hashrate()
            self.collect_gas_price()
            for block_type in BLOCK_TYPE.as_list():
                self.collect_sync_block(block_type)
                self.collect_block_transactions(block_type)
            self.collect_versions()
        for metric in self.metrics.values():
            yield metric

    @ignore_httperror
    def collect_versions(self):
        versions = {
            'web3': self.web3.version.api,
            'client': self.web3.version.node,
            'network': self.web3.version.network,
            'protocol': self.web3.version.ethereum
        }
        self.metrics['eth_client_version'].add_metric([], versions)

    @ignore_httperror
    def collect_peers(self):
        """Collect the number of connected peers.

        If the target is a parity client, we also record the number of active peers.
        """
        target = f'http://{CLI_ARGS.target_ip}:{CLI_ARGS.target_port}'
        req = requests.post(
            target, json={"method":"parity_netPeers","params":[],"id":1,"jsonrpc":"2.0"})
        peer_count_hex = req.json()['result']
        self.metrics['eth_peers'].add_metric([PEER_STATE.CONNECTED], len(peer_count_hex))
        # Parity exposes more granular data, see:
        #   https://wiki.parity.io/JSONRPC-parity-module#parity_netpeers
        req = requests.post(target, json={"method":"parity_netPeers","params":[],"id":1,"jsonrpc":"2.0"})
        active = req.json()['result']['active']
        self.metrics['eth_peers'].add_metric([PEER_STATE.ACTIVE], active)

    @ignore_httperror
    def collect_hashrate(self):
        """Collect the hashrate of the node."""
        hashrate = self.web3.eth.hashrate
        self.metrics['eth_hashrate'].add_metric([], hashrate)

    @ignore_httperror
    def collect_gas_price(self):
        """Collect the network's current gas price."""
        gas_price = self.web3.eth.gasPrice
        self.metrics['eth_gas_price'].add_metric([], gas_price)

    @ignore_httperror
    def collect_sync_block(self, block_type):
        """Collect the ID number of the given `block_type`'s block."""
        block = self.web3.eth.getBlock(block_identifier=block_type)
        self.metrics[f'eth_sync_block_{block_type}'].add_metric([], block['number'])

    @ignore_httperror
    def collect_block_transactions(self, block_type):
        """Collect the transaction count of the given `block_type`."""
        transaction_count = self.web3.eth.getBlockTransactionCount(block_type)
        self.metrics['eth_block_transactions'].add_metric([block_type], transaction_count)

    @ignore_httperror
    def collect_node_sync_status(self):
        """Collect the node's sync status.

        we convert the web3 method's result into an integer:

            0: not syncing
            1: syncing
        """
        syncing = int(bool(self.web3.eth.syncing))
        self.metrics['eth_node_syncing'].add_metric([], syncing)


def serve_metrics():
    REGISTRY.register(EthereumCollector())
    start_http_server(int(CLI_ARGS.metrics_port))
    while True:
        time.sleep(int(1))


if __name__ == '__main__':
    serve_metrics()